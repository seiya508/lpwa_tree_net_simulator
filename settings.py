#################### settings.py ####################
# Program descriptions and definitions
# @created      2023-12-14
# @developer    226E0214 Seiya Kinoshita
# @affiliation  Tanaka Lab. Kyutech
#################### ########### ####################

import math

############################### パケットの種類 ##############################
# プログラムではJSON形式でパケットを伝搬する．
# パケットの種類"type"ごとに伝搬内容を変える．
# Helloパケットは深さ depth が上限 DEPTH_LIM を超えたら送信不可とする．
DEPTH_LIM = 20
#
# (0) 通常パケット:   任意のメッセージの伝達(未使用)
#     {"type": 0, "clock": clock, "optional": any,...}
#     
# (1) Helloパケット:  経路情報の伝達と子ノード情報の通知
#     {
#      "type"       : 1,
#      "clock"      : clock,
#      "my_id"      : ID,
#      "uplink_id"  : uplink_id
#      "my_depth"   : depth
#      }
#
# (2) Byeパケット:    経路情報と子ノード情報の削除
#     {"type": 2, "clock": clock, "my_id": ID}
#
# (3) Aloneパケット:  子ノードへ経路情報の再伝達を求める
#     {"type": 3, "clock": clock, "my_id": ID}
##############################################################################

############################### 経路制御と子ノードリスト ##############################
# Helloパケットで経路情報を受信したとき，"ルートノードからの深さ depth "と
# "電波強度 rssi "で優先順位を付け，経路候補表と子ノードリストを更新する．
# なお，経路候補表には上方向の経路のみを記録する．
# 構築された経路候補表 candidate_tbl は，以下の通りに並べられる．
# - 親ノードの経路:           経路候補表0番目の要素      candidate_tbl[0]
# - バックアップノードの経路:  経路候補表0番目以降の要素  candidate_tbl[1:]
# 親ノードが変更されたとき，Helloパケットを書き換えて中継する．
# 経路候補表と子ノードリストの具体的な更新手順は以下の通り．
#
# (1) 送信ノードの親が自ノードのとき，子ノードリストに送信ノードIDを追加し，
#     経路候補表に送信ノードの経路が存在すれば，該当経路を削除
#     このとき，経路候補表に経路情報が無くなったら終了
# (2) 送信ノードの親が自ノード以外のとき
#   (2*) 従来のアルゴリズムを検証する場合はis_previous_rouingをTrueに：
#        経路候補表に経路情報が既にあるとき，何もせず終了
is_previous_rouing = False
#
#   (2-1) 子ノードリストに送信ノードIDが含まれているとき
#         子ノードリストから送信ノードIDを削除，経路候補表に送信ノードの経路を挿入・更新処理[※]
#   (2-2) 子ノードリストに送信ノードIDが含まれていないとき
#         経路候補表に送信ノードの経路を挿入・更新[※]
# (3) (2-1), (2-2)において親ノード(0番要素)が更新されたとき，
#     自ノード情報に書き換えたHelloパケットを中継
#
# [※]経路候補表への対象経路の挿入・更新処理
# (1) 経路候補表に経路情報が無いとき，対象経路を追加して終了  
# (2) 経路候補表に経路情報が存在するとき，経路候補表に送信ノードの経路が存在すれば，
#     該当経路を削除して，経路候補表の0番要素から参照する
#   (2-1) 対象経路の深さが参照経路の深さより小さいとき，その直前に挿入して終了      
#   (2-2) 対象経路の深さが参照経路の深さと等しく，対象経路の電波強度が参照経路の電波強度より大きいとき，その直前に挿入して終了
#         そうでない場合，経路候補表の次の要素を参照して(2-1)から続行
# (3) 経路候補表末尾に対象経路を追加して終了
#######################################################################################

#################################### 時系列管理 ###################################
# 論理時計 clock によって時系列と経路保持状態を管理する．
# ルートノードが前回と違うパケットを送るごとにインクリメント(Hello->Bye->Hello->Bye...)
# 偶数: 経路初期化状態
# 奇数: 経路構築状態
##################################################################################

##################################### 時間測定 ####################################
# (チャンネル数) 125kHz以下:38ch, 250kHz:19ch
# 今回はすべてのノードが同一チャンネルで通信すると仮定する．
# つまり，あるノードの通信とその周囲(通信可能範囲にある)ノードの通信は同時には行われない．
# また，キャリアセンス時間やノードの障害検知にかかる時間も考慮しない．
# このとき，以下の手順で予想経過時間を計測する．
# 
# (1) あるノードが送信処理をしたとき，送信済みノード履歴 sent_nodes_history にノードを記録
#     また，当該ノードの送信経過時間 pause_time を初期化
# (2) 次に送信するノードが，履歴に記録されたノードの周囲ノードであるとき，
#     履歴を消去して送信時間 SENDING_TIME をすべてのノードの送信待ち時間 waiting_time, 
#     送信経過時間 pause_time, 予想経過時間 time に加算
#     なお，ノードは送信経過時間が送信休止時間 SENDING_INTERVAL 以上となると通信が可能
# (3) すべてのノードの送信処理が終了したとき，
#     すべてのノードの送信経過時間が送信休止時間以上(レディ状態)となるまで送信時間を予想経過時間に加算して(1)へ戻る
#
# 送信時間[ms](S920LR3データシート参照：ペイロード10bytes)
# SENDING_MIN_TIME = 52         # 最小値：帯域幅250kHz, SF5   (通信距離短; 消費電力小)
SENDING_TIME = 72               # おおよその平均値：帯域幅125kHz, SF7
# SENDING_MAX_TIME = 2966       # 最大値：帯域幅62.5kHz, SF12 (通信距離長; 消費電力大)

# 送信休止時間(送信時間の10倍が目安送信休止時間)
SENDING_INTERVAL = 10 * SENDING_TIME
##################################################################################

######################################### 電波強度(RSSI)の算出 #########################################
AVAILABLE_DIST = 5.0                    # 通信可能距離[km](ES920LR3データシート参照：外付けワイヤーアンテナ装着時)
RSSI_UPLIM, RSSI_LWLIM = -30.0, -140.0  # RSSI上限/下限値(ES920LR3データシート参照：PER(パケットエラーレート)1%未満時)

# 以下の連立方程式を整理:
# 上限値(距離0.0001のとき):         RSSI_UPLIM = M - 10*N*log_10(0.0001)
# 下限値(距離AVAILABLE_DISTのとき): RSSI_LWLIM = M - 10*N*log_10(AVAILABLE_DIST)

M = (10*math.log10(AVAILABLE_DIST)*RSSI_UPLIM + 40*RSSI_LWLIM) / (40 + 10*math.log10(AVAILABLE_DIST))
N = (RSSI_UPLIM-RSSI_LWLIM) / (40 + 10*math.log10(AVAILABLE_DIST))

# 距離算出
def calc_dist(pos0: tuple, pos1: tuple) -> float:
  return  math.sqrt((pos0[0] - pos1[0])**2 + (pos0[1] - pos1[1])**2)

# RSSI算出(フリスの伝達公式)
def calc_rssi(pos0: tuple, pos1: tuple) -> float:
  d = calc_dist(pos0, pos1)
  if d == 0:
    print("Warning: RSSI cannot be calculated (Distance = 0).")
    return RSSI_UPLIM
  return  round(M - 10 * N * math.log10(d), 1)

# (参考)
# https://techweb.rohm.co.jp/product/wireless/wireless-communication/wireless-communication-basic/1582/
# https://zenn.dev/yukichi_tech/articles/1539483ed67180
#######################################################################################################

if __name__ == '__main__':
  pass